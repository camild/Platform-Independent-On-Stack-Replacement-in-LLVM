% !TEX root = article.tex

\section{OSR in LLVM}
\label{se:osr-llvm}

% ====> The following text goes in the artifact
% In this section we discuss our implementation of the approach described in \mysection\ref{se:overview} in \tinyvm, a proof-of-concept virtual machine we developed as a playground to exercise our OSR techniques. TinyVM is based on LLVM's MCJIT compiler and supports interactive invocation of LLVM IR functions either generated at run-time or loaded from disk. The main design goal behind TinyVM is the creation of an interactive environment for IR manipulation and JIT-compilation of functions: for instance, it allows the user to insert OSR points in loaded functions, run optimization passes on them or display their CFGs, repeatedly invoke a function for a specified amount of times and so on. TinyVM supports dynamic library loading and linking, and comes with a helper component for MCJIT that simplifies tasks such as handling multiple IR modules, symbol resolution in presence of multiple versions of a function, and tracking native code and other machine-level generated object such as Stackmaps.

\ifdefined\noauthorea
\begin{figure}[t]
\begin{center}
\includegraphics[width=0.9\columnwidth]{figures/isord-example/isord.eps}
\caption{\protect\input{figures/isord-example/caption}}
\end{center}
\end{figure}
\fi

%\subsection{Example}
In this section we discuss how to implement the OSR approach of \mysection\ref{se:overview} in LLVM. Our discussion is based on an example that illustrates a profile-driven optimization scenario, where control is dynamically diverted to a faster version if the number of iterations of a base function exceeds a certain threshold. The IR code shown in this section has been generated with \osrkit, an LLVM-based library we prototyped to support VM builders with a set of abstractions for OSR instrumentation of IR code.

The example we consider consists in a simple base function {\tt isord} that checks whether an array of numbers is ordered according to some criterion specified by a comparator, as shown in \myfigure\ref{fi:isord-example}.

%To explain how the OSR approach of \mysection\ref{se:overview} can be implemented in LLVM, we consider the simple example of \myfigure\ref{fi:isord-example}. Function {\tt isord} checks whether an array of numbers is ordered according to some criterion specified by a comparator.

\ifdefined\noauthorea
\begin{figure}[t]
\begin{center}
\includegraphics[width=0.9\columnwidth]{figures/isordfrom/isordfrom.eps}
\caption{\protect\input{figures/isordfrom/caption}}
\end{center}
\end{figure}
\fi

\ifdefined\noauthorea
\begin{figure}[t]
\begin{center}
\includegraphics[width=0.9\columnwidth]{figures/isordascto/isordascto.eps}
\caption{\protect\input{figures/isordascto/caption}}
\end{center}
\end{figure}
\fi

\section{OSR Instrumentation in IR.}
\label{se:ir-osr-instr}
We use deferred compilation by instrumenting {\tt isord} with an open OSR at the beginning of the loop body, as shown in \myfigure\ref{fig:isordfrom}. Portions added to the original code by OSR istrumentation are highlighted in grey\footnote{Virtual register names and labels in the LLVM-produced IR code have been refactored to make the code more readable.}.
%The figure illustrates how the original {\tt isord} code is instrumented by \tinyvm, highlighting in grey the added portions. 
A new basic block is placed at the beginning of the loop body, which increments a hotness counter {\tt p.osr} and jumps to an OSR-firing block if the counter reaches the threshold (1000 iterations in this example). The OSR block contains a tail call to the target generation stub, which receives as parameters the four live variables at the OSR point ({\tt v}, {\tt n}, {\tt i}, {\tt c}). Notice that maintaining the SSA form requires adjusting $\phi$-nodes. The stub (see \myfigure[...]) calls a code generator that: 1) builds an optimized version of {\tt isord} by inlining the comparator (which is known when the OSR is fired), and 2) uses it to create the continuation function {\tt isordto} shown in \myfigure\ref{fig:isordascto}. The stub terminates with a tail call to {\tt isordto}. To generate the continuation function from the optimized version created by the inliner, we need to replace the function entry point, remove dead code, replace live variables with the function parameters, and fix $\phi$-nodes accordingly. Additions resulting from the IR instrumentation are in grey, while removals are struck-through.


\ifdefined\noauthorea
\begin{figure}[t]
\begin{center}
\includegraphics[width=0.9\columnwidth]{figures/isordx86-64/isordx86-64.eps}
\caption{\protect\input{figures/isordx86-64/caption}}
\end{center}
\end{figure}
\fi

\paragraph{x86-64 Lowering.}
\label{se:ir-x86-lowering}

%The final step to be performed before execution is native code generation. 
\myfigure\ref{fig:isordx86-64} shows the x86-64 code generated by LLVM for {\tt isordfrom} and {\tt isordto}. For the sake of comparison with the native code that would be generated for the original non-OSR versions, additions resulting from the IR instrumentation are in grey, while removals are struck-through. Notice that the OSR intrusiveness in {\tt isordfrom} is minimal, consisting of just two assembly instructions with register and immediate operands. As a result of induction variable canonicalization in the LLVM back-end, loop index {\tt i} and hotness counter {\tt p.osr} are fused in register {\tt\%r12}. We also note that tail call optimization is applied in the OSR-firing block, resulting in no stack growth during an OSR. The continuation function {\tt isordto} is identical to the optimized version of {\tt isord}, except that the loop index is passed as a parameter in {\tt \%rdx} and no loop pre-header is needed since OSR jumps directly in the loop body.

%\subsection{\osrkit\ Instrumentation API}
%\label{se:instrum-api}
%To support the IR instrumentation tasks of \mysection\ref{se:overview}, \osrkit\ provides a number of abstractions for VM builders. 

%In this section we discuss an LLVM implementation of the approach described in \mysection\ref{se:overview}. Our discussion is based on a set of abstractions to support OSR instrumentation of IR code, which we organized in an LLVM-based library for VM builders called \osrkit. A simplified overview of the main building blocks is:
%\begin{itemize}
%\item {\em StateMapper}: a class that [...]
%\item {\em InsertResolvedOSR(f1, b1, f2, b2, cond, m)}: function that inserts a resolved OSR point in function {\em f1} at basic block {\em b1} to function {\em f2} at basic block {\em b2}, using as OSR condition a sequence of IR instructions {\em cond} and a state mapper {\em m}.
%\item {\em InsertOpenOSR()}: [...]
%\item {\em GenerateOSRContFun(...)}: generates the continuation function [...]
%\end{itemize}

%LLVMContext& Context, OSRLibrary::OpenOSRInfo& info,
%        OSRLibrary::OSRCond& cond, Value* profDataVal, OSRLibrary::DestFunGenerator destFunGenerator,
%        std::vector<Value*> *valuesToTransfer, OSRLibrary::OSRPointConfig &config
%Function* src, BasicBlock* src_bb, std::string* F1NewName, OSRLibrary::OSRCond &cond, int branchTakenProb

%The generated stub calls a function inliner that generates a version of {\tt isord} where the comparator's body, pointed to by live variable {\tt c_osr}, is inlined in the loop body. The optimized version {\tt isordto} is shown in \myfigure\ref{fig:isordascto}.
