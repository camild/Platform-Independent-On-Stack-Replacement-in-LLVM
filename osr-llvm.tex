% !TEX root = article.tex

\section{OSR in LLVM}
\label{se:osr-llvm}

In this section we discuss our implementation of the approach described in \mysection\ref{se:overview} in \tinyvm, a proof-of-concept virtual machine we developed as a playground to exercise our OSR techniques. TinyVM is based on LLVM's MCJIT compiler and supports interactive invocation of LLVM IR functions either generated at run-time or loaded from disk. The main design goal behind TinyVM is the creation of an interactive environment for IR manipulation and JIT-compilation of functions: for instance, it allows the user to insert OSR points in loaded functions, run optimization passes on them or display their CFGs, repeatedly invoke a function for a specified amount of times and so on. TinyVM supports dynamic library loading and linking, and comes with a helper component for MCJIT that simplifies tasks such as handling multiple IR modules, symbol resolution in presence of multiple versions of a function, and tracking native code and other machine-level generated object such as Stackmaps.

To explain how OSR can be encoded in IR using \tinyvm, we consider the toy example of \myfigure\ref{fi:isord-example}. Function {\tt isord} checks whether an array of numbers is sorted according to some ordering given by a comparator. The scenario we explore is profile-driven optimization, where we dynamically divert control to a faster version if the number of iterations exceeds a certain threshold. To achieve this goal, we use deferred compilation by instrumenting {\tt isord} in \tinyvm\ with an open OSR at the beginning of the loop body, as shown in \myfigure\ref{fig:isordfrom}. The figure shows how the original {\tt isord} code is instrumented by \tinyvm, highlighting in grey the added portions. A new basic block is placed at the beginning of the loob body, incrementing the hotness counter {\tt p.osr} and testing if it reached the threshold (1000 iterations in this example). Notice that maintaining the SSA form requires adjusting phi nodes.

%To place an open OSR, \tinyvm\ requires the following pieces of information: 1) a pointer to the 

%LLVMContext& Context, OSRLibrary::OpenOSRInfo& info,
%        OSRLibrary::OSRCond& cond, Value* profDataVal, OSRLibrary::DestFunGenerator destFunGenerator,
%        std::vector<Value*> *valuesToTransfer, OSRLibrary::OSRPointConfig &config
%Function* src, BasicBlock* src_bb, std::string* F1NewName, OSRLibrary::OSRCond &cond, int branchTakenProb


%OSR instrumentation produces function {\tt isordfrom} obtained from {\tt isord} by including 

%includes extra code (in grey) that increments a counter , 

%The generated stub calls a function inliner that generates a version of {\tt isord} where the comparator's body, pointed to by live variable {\tt c_osr}, is inlined in the loop body. The optimized version {\tt isordto} is shown in \myfigure\ref{fig:isordascto}.

\ifdefined\noauthorea
\begin{figure}[t]
\begin{center}
\includegraphics[width=0.9\columnwidth]{figures/isord-example/isord.eps}
\caption{\protect\input{figures/isord-example/caption}}
\end{center}
\end{figure}
\fi

\ifdefined\noauthorea
\begin{figure}[t]
\begin{center}
\includegraphics[width=0.9\columnwidth]{figures/isordfrom/isordfrom.eps}
\caption{\protect\input{figures/isordfrom/caption}}
\end{center}
\end{figure}
\fi

\ifdefined\noauthorea
\begin{figure}[t]
\begin{center}
\includegraphics[width=0.9\columnwidth]{figures/isordascto/isordascto.eps}
\caption{\protect\input{figures/isordascto/caption}}
\end{center}
\end{figure}
\fi

\ifdefined\noauthorea
\begin{figure}[t]
\begin{center}
\includegraphics[width=0.9\columnwidth]{figures/isordx86-64/isordx86-64.eps}
\caption{\protect\input{figures/isordx86-64/caption}}
\end{center}
\end{figure}
\fi

%\subsection{Resolved OSR Points}

%\subsection{Open OSR Points}
  

  
  
  
  