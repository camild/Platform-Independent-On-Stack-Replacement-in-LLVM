% !TEX root = ../article.tex

\subsubsection{Session 1: OSR instrumentation in \osrkit}

\tinyvm\ implements a code generator for open OSR points that can dynamically inline a method whose address cannot be determined when the calling function is compiled. In the example from \myfigure\ref{fi:isord-example}, a comparator function {\tt c} is passed as argument to function {\tt isord}, which checks whether an array {\tt v} of {\tt long} is ordered according to the criterion encoded in {\tt c}.

To interactively reproduce the experiment presented in \mysection\ref{se:osr-llvm}, we provide under the folder {\small\tt tinyvm/isord} a C driver {\small\tt inline.c} with an LLVM IR counterpart {\small\tt inline.ll} (generated with {\small\tt clang -S -emit-llvm -O1 inline.c}).

We can load the IR module in \tinyvm\ and show the code generated for method {\tt isord} with:
\begin{small}
\begin{verbatim}
osrkit@osrkit-AE:~/Desktop/tinyvm$ tinyvm
Welcome! Enter 'HELP' to show the list of commands.
TinyVM> LOAD_IR isord/inline.ll
[LOAD] Opening "isord/inline.ll" as IR source file...
TinyVM> DUMP isord
[...]
\end{verbatim}
\end{small}

\noindent Displayed virtual register names and basic block labels will often differ from those reported in \myfigure\ref{fig:isordfrom}, which have been refactored for the sake of readability. In particular, the loop body of {\tt isord} will look like:

\begin{small}
\begin{verbatim}
.lr.ph:                            ; preds = %2, %0
  %i.01 = phi i64 [ %10, %2 ], [ 1, %0 ]
  %4 = getelementptr inbounds i64* %v, i64 %i.01
  %.sum = add nsw i64 %i.01, -1
  %5 = getelementptr inbounds i64* %v, i64 %.sum
  %6 = bitcast i64* %5 to i8*
  %7 = bitcast i64* %4 to i8*
  %8 = tail call i32 %c(i8* %6, i8* %7) #3
  [...]
\end{verbatim}
\end{small}

\noindent

%In a usage scenario in which input arrays are large, we might want to perform dynamic inlining as early as possible. We can thus insert 