% !TEX root = ../article.tex

\subsubsection{Session 1: OSR instrumentation in \osrkit}

\tinyvm\ implements a code generator for open OSR points that can dynamically inline a method whose address cannot be determined when the calling function is compiled. In the example from \myfigure\ref{fi:isord-example}, a comparator function {\tt c} is passed as argument to function {\tt isord}, which checks whether an array {\tt v} is ordered according to the criterion encoded in {\tt c}.

To interactively reproduce the experiment presented in \mysection\ref{se:osr-llvm}, we provide under the folder {\small\tt tinyvm/isord} a C driver {\small\tt inline.c} with an LLVM IR counterpart {\small\tt inline.ll} (generated with {\small\tt clang -S -emit-llvm -O1 inline.c}).

We can load the IR module in \tinyvm\ and show the code generated for method {\tt isord} with:
\begin{small}
\begin{verbatim}
osrkit@osrkit-AE:~/Desktop/tinyvm$ tinyvm
Welcome! Enter 'HELP' to show the list of commands.
TinyVM> LOAD_IR isord/inline.ll
[LOAD] Opening "isord/inline.ll" as IR source file...
TinyVM> DUMP isord
[...]
\end{verbatim}
\end{small}

\noindent Displayed virtual register names and basic block labels will often differ from those reported in \myfigure\ref{fig:isordfrom}, which have been refactored for the sake of readability. In particular, the loop body of {\tt isord} will look like:

\begin{small}
\begin{verbatim}
.lr.ph:                            ; preds = %2, %0
  %i.01 = phi i64 [ %10, %2 ], [ 1, %0 ]
  %4 = getelementptr inbounds i64* %v, i64 %i.01
  %.sum = add nsw i64 %i.01, -1
  %5 = getelementptr inbounds i64* %v, i64 %.sum
  %6 = bitcast i64* %5 to i8*
  %7 = bitcast i64* %4 to i8*
  %8 = tail call i32 %c(i8* %6, i8* %7) #3
  [...]
\end{verbatim}
\end{small}

\noindent A $\phi$-node {\tt \%i.01} is used to represent the index of the C {\tt for} loop, and is set to {\tt \%10} when reached from the loop header (basic block {\tt \%2}) {\em after} a loop iteration. In fact, as a result of {\small \tt -O1} optimizations, with {\tt n>1} execution jumps from the function entrypoint {\tt \%0} directly into the loop body, initializing the $\phi$-node with {\tt 1}. Comparator {\tt c} is invoked with a tail call, storing its return value into virtual register {\tt \%8}.

OSR points can be inserted with the {\tt INSERT\_OSR} command, which allows several combinations of features (see {\tt HELP} for details). In this session we will modify {\tt isord} so that when the loop body is entered for the first time, an OSR is promptly fired:

\begin{small}
\begin{verbatim}
TinyVM> INSERT_OSR 100 ALWAYS OPEN UPDATE IN isord
                   AT %4 DYN_INLINE %c
\end{verbatim}
\end{small}

\noindent \tinyvm\ will {\tt UPDATE} the function in the following way: an {\tt ALWAYS}-true OSR condition is verified before executing instruction {\tt \%4}, firing an {\tt OPEN} OSR transition in the {\tt DYN\_INLINE} code generator that will inline any indirect function call to the function pointer {\tt \%c}. We choose {\tt \%4} as location for the OSR as its the first non-$\phi$ instruction in the loop body, and we hint the LLVM backend that the OSR firing is {\tt 100}\%-likely.

%In a usage scenario in which input arrays are large, we might want to perform dynamic inlining as early as possible. We can thus insert 